/*
 * This Java source file was generated by the Gradle 'init' task.
 * Promise只有在() -> { return Promise(); } 才能切换执行线程
 */
package team.qtk.promise;

import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.impl.NoStackTraceThrowable;
import lombok.Builder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

//
@Builder
public class Promise {

    private static PromiseInstance promiseInstance = new PromiseInstance();

    public static void setGlobalVertx(Vertx vertx) {
        Promise.promiseInstance = new PromiseInstance(vertx);
    }

    /**
     * 使用Vertx实例来管理异步执行线程
     */
    public static PromiseInstance setVertx(Vertx vertx) {
        return new PromiseInstance(vertx);
    }

    public static class PromiseInstance {
        private Vertx vertx;

        public PromiseInstance() {

        }

        public PromiseInstance(Vertx vertx) {
            this.vertx = vertx;
        }

        public Async<Void> resolve() {
            return resolve((Void) null);
        }

        public <T> Async<T> resolve(T value) {
            return Async.<T>builder().vertx(vertx).future(Future.succeededFuture(value)).build();
        }

        /**
         * 执行异步函数
         * 等同于Promise.resolve().then(supplier)
         */
        public <T> Async<T> resolve(Supplier<T> supplier) {
            return resolve().then(supplier);
        }

        /**
         * 异步等待Vertx.Future返回
         * Vertx.Future在是一旦定义就立即触发
         */
        public <T> Async<T> resolve(Future<T> future) {
            return Async.<T>builder().vertx(vertx).future(future).build();
        }

        private <T> Async<T> resolve(Future<T> future, List<io.vertx.core.Promise> deferPromises) {
            return Async.<T>builder().vertx(vertx).future(future).deferPromises(deferPromises).build();
        }

        /**
         * 异步等待Vertx.CompositeFuture返回，并将每个Vertx.Future结果按顺序放入List
         * 若想指定Vertx.CompositeFuture执行线程请使Promise.resolve(RunOn.xxx, () -> Promise.resolve(Vertx.CompositeFuture))
         */

        public <Object> Async<List<Object>> resolve(CompositeFuture future) {
            var newFuture = Future.<List<Object>>future(promise -> future.onComplete(
                h -> {
                    if (h.succeeded()) {
                        promise.complete(h.result().list());
                    } else {
                        promise.fail(
                            h.cause() instanceof NoStackTraceThrowable ?
                                new RuntimeException(h.cause().getMessage()) :
                                h.cause()
                        );
                    }
                }
            ));
            return resolve(newFuture);
        }

        /**
         * 包装一个lambda函数，当传入的参数(一个方法(Vertx.Handler))被调用时，返回结果值
         * 例如:Promise.<Long>resolve(doneCallback ->  Vertx.vertx().setTimer(3000, doneCallback))
         */
        public <T> Async<T> resolve(Consumer<Handler<T>> consumer) {
            var newFuture = Future.<T>future(promise -> {
                try {
                    consumer.accept(promise::complete);
                } catch (Throwable error) {
                    promise.fail(error);
                }
            });

            return resolve(newFuture);
        }

        /**
         * 并发执行多个【同类型Promise】，并将结果依次返回。
         * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
         */
        public <T> Async<List<T>> allSameType(List<Async<T>> promises) {
            var deferPromises = new ArrayList<io.vertx.core.Promise>();
            var futures = promises.stream()
                .map(promise -> {
                    // 若有惰性resolve，则进行合并
                    if (!promise.getDeferPromises().isEmpty()) deferPromises.addAll(promise.getDeferPromises());

                    return promise.getFuture();
                })
                .toList();

            var newFuture = Future.<List<T>>future(promise -> Future.all(futures).onComplete(
                h -> {
                    if (h.succeeded()) {
                        promise.complete(h.result().list());
                    } else {
                        promise.fail(
                            h.cause() instanceof NoStackTraceThrowable ?
                                new RuntimeException(h.cause().getMessage()) :
                                h.cause()
                        );
                    }
                }
            ));

            return resolve(newFuture, deferPromises);
        }

        /**
         * 并发执行多个【同类型Promise】，并将结果依次返回。
         * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
         */

        public <T> Async<List<T>> allSameType(Async<T>... promises) {
            return allSameType(Arrays.asList(promises));
        }

        /**
         * 并发执行多个【同类型Promise】，并将结果依次返回。
         * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
         */
        public <T> Async<List<T>> allSettledSameType(List<Async<T>> promises) {
            var deferPromises = new ArrayList<io.vertx.core.Promise>();
            var futures = promises.stream()
                .map(promise -> {
                    // 若有惰性resolve，则进行合并
                    if (!promise.getDeferPromises().isEmpty()) deferPromises.addAll(promise.getDeferPromises());

                    return promise.getFuture();
                })
                .map(f -> f.recover(throwable -> throwable instanceof NoStackTraceThrowable ?
                    Future.succeededFuture((T) new RuntimeException(throwable.getMessage())) :
                    Future.succeededFuture((T) throwable))) //出错的future转为正确的
                .toList();

            var newFuture = Future.<List<T>>future(promise -> Future.join(futures).onComplete(
                h -> {
                    if (h.succeeded()) {
                        promise.complete(h.result().list());
                    } else {
                        promise.fail(
                            h.cause() instanceof NoStackTraceThrowable ?
                                new RuntimeException(h.cause().getMessage()) :
                                h.cause()
                        );
                    }
                }
            ));
            return resolve(newFuture, deferPromises);
        }

        /**
         * 并发执行多个【同类型Promise】，并将结果依次返回。
         * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
         */

        public <T> Async<List<T>> allSettledSameType(Async<T>... promises) {
            return allSettledSameType(Arrays.asList(promises));
        }

        /**
         * 并发执行多个【同类型Promise】，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
         */
        public <T> Async<T> raceSameType(List<Async<T>> promises) {
            var deferPromises = new ArrayList<io.vertx.core.Promise>();
            var futures = promises.stream()
                .map(promise -> {
                    // 若有惰性resolve，则进行合并
                    if (!promise.getDeferPromises().isEmpty()) deferPromises.addAll(promise.getDeferPromises());

                    return promise.getFuture();
                })
                .map(f -> f.recover(throwable -> throwable instanceof NoStackTraceThrowable ?
                    Future.succeededFuture((T) new RuntimeException(throwable.getMessage())) :
                    Future.succeededFuture((T) throwable))) //出错的future转为正确的
                .toList();

            var newFuture = Future.<T>future(promise -> Future.any(futures).onComplete(
                h -> {
                    if (h.succeeded()) {
                        var nowResult = h.result();
                        Object first = null;

                        // 寻找第一个完成的元素
                        for (var i = 0; i < futures.size(); i++) {
                            if (nowResult.isComplete(i)) {
                                first = nowResult.resultAt(i);
                                break;
                            }
                        }

                        if (first instanceof Throwable firstError) {
                            promise.fail(
                                firstError instanceof NoStackTraceThrowable ?
                                    new RuntimeException(firstError.getMessage()) :
                                    firstError
                            );
                        } else {
                            promise.complete((T) first);
                        }
                    } else {
                        promise.fail(
                            h.cause() instanceof NoStackTraceThrowable ?
                                new RuntimeException(h.cause().getMessage()) :
                                h.cause()
                        );
                    }
                }
            ));
            return resolve(newFuture, deferPromises);
        }

        /**
         * 并发执行多个【同类型Promise】，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
         */

        public <T> Async<T> raceSameType(Async<T>... promises) {
            return raceSameType(Arrays.asList(promises));
        }

        /**
         * 并发执行多个【同类型Promise】，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
         */
        public <T> Async<T> anySameType(List<Async<T>> promises) {
            var deferPromises = new ArrayList<io.vertx.core.Promise>();
            var futures = promises.stream()
                .map(promise -> {
                    // 若有惰性resolve，则进行合并
                    if (!promise.getDeferPromises().isEmpty()) deferPromises.addAll(promise.getDeferPromises());

                    return promise.getFuture();
                })
                .toList();

            var newFuture = Future.<T>future(promise -> Future.any(futures).onComplete(
                h -> {
                    if (h.succeeded()) {
                        var nowResult = h.result();
                        Object first = null;

                        // 寻找第一个完成的元素
                        for (var i = 0; i < futures.size(); i++) {
                            if (nowResult.isComplete(i)) {
                                first = nowResult.resultAt(i);
                                break;
                            }
                        }

                        promise.complete((T) first);
                    } else {
                        promise.fail(
                            h.cause() instanceof NoStackTraceThrowable ?
                                new RuntimeException(h.cause().getMessage()) :
                                h.cause()
                        );
                    }
                }
            ));
            return resolve(newFuture, deferPromises);
        }

        /**
         * 并发执行多个【同类型Promise】，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
         */

        public <T> Async<T> anySameType(Async<T>... promises) {
            return anySameType(Arrays.asList(promises));
        }

        /**
         * 并发执行多个Promise，并将结果依次返回。
         * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
         */
        public Async<List<Object>> all(List<Async<?>> promises) {
            return allSameType((List) promises);
        }

        /**
         * 并发执行多个Promise，并将结果依次返回。
         * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
         */
        public Async<List<Object>> all(Async<?>... promises) {
            return all(Arrays.asList(promises));
        }

        /**
         * 并发执行多个Promise，并将结果依次返回。
         * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
         */
        public Async<List<Object>> allSettled(List<Async<?>> promises) {
            return allSettledSameType((List) promises);
        }

        /**
         * 并发执行多个Promise，并将结果依次返回。
         * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
         */
        public Async<List<Object>> allSettled(Async<?>... promises) {
            return allSettled(Arrays.asList(promises));
        }

        /**
         * 并发执行多个Promise，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
         */
        public Async<Object> race(Async<?>... promises) {
            return race(Arrays.asList(promises));
        }

        /**
         * 并发执行多个Promise，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
         */
        public Async<Object> race(List<Async<?>> promises) {
            return raceSameType((List) promises);
        }

        /**
         * 并发执行多个Promise，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
         */
        public Async<Object> any(List<Async<?>> promises) {
            return anySameType((List) promises);
        }

        /**
         * 并发执行多个Promise，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
         */
        public Async<Object> any(Async<?>... promises) {
            return any(Arrays.asList(promises));
        }

        /**
         * 抛出RuntimeException("reject")错误
         */
        public Async<RuntimeException> reject() {
            return reject("reject");
        }

        /**
         * 抛出RuntimeException(errorMessage)错误
         */
        public Async<RuntimeException> reject(String errorMessage) {
            return Async.<RuntimeException>builder().vertx(vertx)
                .future(Future.failedFuture(new RuntimeException(errorMessage)))
                .build();
        }

        /**
         * 抛出自定义错误
         */
        public <T extends Throwable> Async<T> reject(T t) {
            return Async.<T>builder().vertx(vertx)
                .future(Future.failedFuture(t))
                .build();
        }

        public Async<Void> deferResolve() {
            return Async.<Void>builder().vertx(vertx).build().deferResolve();
        }
    }

    public static Async<Void> resolve() {
        return Promise.promiseInstance.resolve();
    }

    public static <T> Async<T> resolve(T value) {
        return Promise.promiseInstance.resolve(value);
    }

    /**
     * 执行异步函数
     * 等同于Promise.resolve().then(supplier)
     */
    public static <T> Async<T> resolve(Supplier<T> supplier) {
        return resolve().then(supplier);
    }

    /**
     * 异步等待Vertx.Future返回
     * Vertx.Future在是一旦定义就立即触发
     */
    public static <T> Async<T> resolve(Future<T> future) {
        return Promise.promiseInstance.resolve(future);
    }

    private static <T> Async<T> resolve(Future<T> future, List<io.vertx.core.Promise> deferPromises) {
        return Promise.promiseInstance.resolve(future, deferPromises);
    }

    /**
     * 异步等待Vertx.CompositeFuture返回，并将每个Vertx.Future结果按顺序放入List
     * 若想指定Vertx.CompositeFuture执行线程请使Promise.resolve(RunOn.xxx, () -> Promise.resolve(Vertx.CompositeFuture))
     */

    public static <Object> Async<List<Object>> resolve(CompositeFuture future) {
        return Promise.promiseInstance.resolve(future);
    }

    /**
     * 包装一个lambda函数，当传入的参数(一个方法(Vertx.Handler))被调用时，返回结果值
     * 例如:Promise.<Long>resolve(doneCallback ->  Vertx.vertx().setTimer(3000, doneCallback))
     */
    public static <T> Async<T> resolve(Consumer<Handler<T>> consumer) {
        return Promise.promiseInstance.resolve(consumer);
    }

    /**
     * 并发执行多个【同类型Promise】，并将结果依次返回。
     * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
     */
    public static <T> Async<List<T>> allSameType(List<Async<T>> promises) {
        return Promise.promiseInstance.allSameType(promises);
    }

    /**
     * 并发执行多个【同类型Promise】，并将结果依次返回。
     * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
     */
    @SafeVarargs
    public static <T> Async<List<T>> allSameType(Async<T>... promises) {
        return allSameType(Arrays.asList(promises));
    }

    /**
     * 并发执行多个【同类型Promise】，并将结果依次返回。
     * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
     */
    public static <T> Async<List<T>> allSettledSameType(List<Async<T>> promises) {
        return Promise.promiseInstance.allSettledSameType(promises);
    }

    /**
     * 并发执行多个【同类型Promise】，并将结果依次返回。
     * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
     */
    @SafeVarargs
    public static <T> Async<List<T>> allSettledSameType(Async<T>... promises) {
        return allSettledSameType(Arrays.asList(promises));
    }

    /**
     * 并发执行多个【同类型Promise】，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
     */
    public static <T> Async<T> raceSameType(List<Async<T>> promises) {
        return Promise.promiseInstance.raceSameType(promises);
    }

    /**
     * 并发执行多个【同类型Promise】，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
     */
    @SafeVarargs
    public static <T> Async<T> raceSameType(Async<T>... promises) {
        return raceSameType(Arrays.asList(promises));
    }

    /**
     * 并发执行多个【同类型Promise】，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
     */
    public static <T> Async<T> anySameType(List<Async<T>> promises) {
        return Promise.promiseInstance.anySameType(promises);
    }

    /**
     * 并发执行多个【同类型Promise】，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
     */
    @SafeVarargs
    public static <T> Async<T> anySameType(Async<T>... promises) {
        return anySameType(Arrays.asList(promises));
    }

    /**
     * 并发执行多个Promise，并将结果依次返回。
     * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
     */
    public static Async<List<Object>> all(List<Async<?>> promises) {
        return allSameType((List) promises);
    }

    /**
     * 并发执行多个Promise，并将结果依次返回。
     * 若其中一个Promise抛错，则将终止等待所有Promise结果并立即抛出错误
     */
    public static Async<List<Object>> all(Async<?>... promises) {
        return all(Arrays.asList(promises));
    }

    /**
     * 并发执行多个Promise，并将结果依次返回。
     * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
     */
    public static Async<List<Object>> allSettled(List<Async<?>> promises) {
        return allSettledSameType((List) promises);
    }

    /**
     * 并发执行多个Promise，并将结果依次返回。
     * 将等待所有Promise结果返回(无论是正常返回还是抛错)，返回列表里每个item为正常数据或者error
     */
    public static Async<List<Object>> allSettled(Async<?>... promises) {
        return allSettled(Arrays.asList(promises));
    }

    /**
     * 并发执行多个Promise，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
     */
    public static Async<Object> race(Async<?>... promises) {
        return race(Arrays.asList(promises));
    }

    /**
     * 并发执行多个Promise，当其中某个Promise最先出结果时(正常返回或者抛错)，立即返回该结果。
     */
    public static Async<Object> race(List<Async<?>> promises) {
        return raceSameType((List) promises);
    }

    /**
     * 并发执行多个Promise，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
     */
    public static Async<Object> any(List<Async<?>> promises) {
        return anySameType((List) promises);
    }

    /**
     * 并发执行多个Promise，当其中某个Promise出正常结果时(抛错则跳过，继续等待)，立即返回该结果
     */
    public static Async<Object> any(Async<?>... promises) {
        return any(Arrays.asList(promises));
    }

    /**
     * 抛出RuntimeException("reject")错误
     */
    public static Async<RuntimeException> reject() {
        return reject("reject");
    }

    /**
     * 抛出RuntimeException(errorMessage)错误
     */
    public static Async<RuntimeException> reject(String errorMessage) {
        return Promise.promiseInstance.reject(errorMessage);
    }

    /**
     * 抛出自定义错误
     */
    public static <T extends Throwable> Async<T> reject(T t) {
        return Promise.promiseInstance.reject(t);
    }

    public static Async<Void> deferResolve() {
        return Promise.promiseInstance.deferResolve();
    }

}

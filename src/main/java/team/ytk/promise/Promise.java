/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package team.ytk.promise;

import io.github.vipcxj.jasync.spec.JAsync;
import io.github.vipcxj.jasync.spec.JPromise;
import io.smallrye.mutiny.Uni;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;
import team.ytk.jasync.mutiny.Promises;

public class Promise {

    public static <T> JPromise<T> resolve(T value) {
        return JAsync.just(value);
    }

    public static <T> JPromise<T> resolve(Future<T> future) {
        return Promises.from(
            Uni
                .createFrom()
                .emitter(
                    emitter -> {
                        future.onComplete(
                            h -> {
                                if (h.succeeded()) {
                                    emitter.complete(h.result());
                                } else {
                                    emitter.fail(h.cause());
                                }
                            }
                        );
                    }
                )
        );
    }

    public static <T> JPromise<List<T>> resolve(CompositeFuture future) {
        return Promises.from(
            Uni
                .createFrom()
                .emitter(
                    emitter -> {
                        future.onComplete(
                            h -> {
                                if (h.succeeded()) {
                                    emitter.complete(h.result().<T>list());
                                } else {
                                    emitter.fail(h.cause());
                                }
                            }
                        );
                    }
                )
        );
    }

    public static <T> JPromise<T> resolve(Consumer<Handler<T>> consumer) {
        return Promises.from(
            Uni
                .createFrom()
                .emitter(
                    emitter -> {
                        consumer.accept(
                            h -> {
                                emitter.complete(h);
                            }
                        );
                    }
                )
        );
    }

    public static <T> JPromise<T> resolve(Uni<T> value) {
        return Promises.from(value);
    }

    public static JPromise<Void> resolve() {
        return JAsync.just();
    }

    public static <T> JPromise<T> reject(Throwable t) {
        return JAsync.error(t);
    }

    public static <T> JPromise<T> reject() {
        return JAsync.error(new RuntimeException("reject"));
    }

    public static <T> JPromise<T> reject(String errorMessage) {
        return JAsync.error(new RuntimeException(errorMessage));
    }

    public static <T> JPromise<T> defer(Supplier<T> deferFunc) {
        return JAsync.defer(() -> JAsync.just(deferFunc.get()));
    }

    @SafeVarargs
    public static JPromise<List<Object>> all(JPromise<? extends Object>... promises) {
        return all(Arrays.asList(promises));
    }

    public static <T> JPromise<List<Object>> all(List<JPromise<? extends Object>> promises) {
        Uni<List<Object>> promiseAll = promises
            .stream()
            .reduce(
                Uni.join().builder(),
                (prev, promise) -> {
                    prev.add(promise.unwrap(Uni.class));

                    return prev;
                },
                (l, r) -> l
            )
            .joinAll()
            .andFailFast();

        return Promises.from(promiseAll);
    }

    @SafeVarargs
    public static JPromise<List<Object>> allSettled(JPromise<? extends Object>... promises) {
        return allSettled(Arrays.asList(promises));
    }

    @SuppressWarnings("unchecked")
    public static JPromise<List<Object>> allSettled(List<JPromise<? extends Object>> promises) {
        Uni<List<Object>> promiseAll = promises
            .stream()
            .reduce(
                Uni.join().builder(),
                (prev, promise) -> {
                    prev.add(
                        ((Uni<Throwable>) promise.unwrap(Uni.class)).onFailure()
                            .recoverWithUni(error -> Uni.createFrom().item(error))
                    );
                    return prev;
                },
                (l, r) -> l
            )
            .joinAll()
            .andCollectFailures();

        return Promises.from(promiseAll);
    }

    @SafeVarargs
    public static JPromise<Object> race(JPromise<? extends Object>... promises) {
        return race(Arrays.asList(promises));
    }

    public static JPromise<Object> race(List<JPromise<? extends Object>> promises) {
        Uni<Object> promiseRace = promises
            .stream()
            .reduce(
                Uni.join().builder(),
                (prev, promise) -> {
                    prev.add(promise.unwrap(Uni.class));
                    return prev;
                },
                (l, r) -> l
            )
            .joinFirst()
            .toTerminate();

        return Promises.from(promiseRace);
    }

    @SafeVarargs
    public static JPromise<Object> any(JPromise<? extends Object>... promises) {
        return any(Arrays.asList(promises));
    }

    public static JPromise<Object> any(List<JPromise<? extends Object>> promises) {
        Uni<Object> promiseRace = promises
            .stream()
            .reduce(
                Uni.join().builder(),
                (prev, promise) -> {
                    prev.add(promise.unwrap(Uni.class));
                    return prev;
                },
                (l, r) -> l
            )
            .joinFirst()
            .withItem();

        return Promises.from(promiseRace);
    }
}

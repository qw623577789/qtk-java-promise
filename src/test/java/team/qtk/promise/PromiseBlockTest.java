/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package team.qtk.promise;

import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.junit5.Checkpoint;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.extension.ExtendWith;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

@ExtendWith(VertxExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PromiseBlockTest {

    @Test
    void resolveInteger() {
        Assertions.assertEquals(Promise.resolve(1).block(), 1);
    }

    @Test
    void resolveString() {
        Assertions.assertEquals(Promise.resolve("1").block(), "1");
    }

    @Test
    void resolveBoolean() {
        Assertions.assertEquals(Promise.resolve(true).block(), true);
    }

    @Test
    void resolveBigDecimal() {
        Assertions.assertEquals(Promise.resolve(new BigDecimal("1")).block(), new BigDecimal("1"));
    }

    @Test
    void resolve() {
        Assertions.assertNull(Promise.resolve().block());
    }

    @Test
    void resolveFutureSuccess(Vertx vertx) {
        Assertions.assertNull(Promise.resolve(Future.succeededFuture(null)).block());
    }

    @Test
    void resolveFutureError() {
        try {
            Assertions.assertNull(Promise.resolve(Future.failedFuture(new RuntimeException("reject"))).block());
        } catch (Exception error) {
            if (error instanceof RuntimeException) {
                Assertions.assertEquals(error.getMessage(), "reject");
            } else {
                Assertions.fail();
            }
        }
    }

    @Test
    void resolveConsumerHandler() {
        Promise.<Long>resolve(doneCallback -> Vertx.vertx().setTimer(3000, doneCallback)).block();

        Long start = System.currentTimeMillis();
        Long[] timerIds = { 999L };
        Long timerId = Promise
            .<Long>resolve(
                doneCallback -> timerIds[0] = Vertx.vertx().setTimer(3000, doneCallback)
            )
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerId);
        Assertions.assertTrue(end - start >= 3000 && timerIds[0].equals(timerId));
    }

    @Test
    void resolveCompositeFutureAll(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        List<Long> timerIds = Promise
            .<Long>resolve(CompositeFuture.all(sleep1.future(), sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
        try {
            Assertions.assertTrue(end - start >= 5000 && !timerIds.get(0).equals(timerIds.get(1)));
            testContext.completeNow();
        } catch (Exception error) {
            testContext.failNow(error);
        }
    }

    @Test
    void resolveCompositeFutureAny(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        List<Long> timerIds = Promise
            .<Long>resolve(CompositeFuture.any(sleep1.future(), sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
        Assertions.assertTrue(
            end - start > 2900 && end - start < 3500 && timerIds.get(0) != null && timerIds.get(1) == null
        );
    }

    @Test
    void resolvePromiseAll(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        List<Object> timerIds = Promise
            .all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
        Assertions.assertTrue(end - start >= 5000 && timerIds.get(0) != timerIds.get(1));
    }

    @SneakyThrows
    @Test
    void resolvePromiseAllSameType(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        List<Long> timerIds = Promise
            .allSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
        Assertions.assertTrue(end - start >= 5000 && !Objects.equals(timerIds.get(0), timerIds.get(1)));
    }

    @Test
    void resolvePromiseAllError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        List<Object> timerIds = new ArrayList<>();
        try {
            timerIds = Promise.all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future())).block();
            Assertions.fail();
        } catch (Exception error) {
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":");
            Assertions.assertTrue(
                end - start >= 5000 &&
                    timerIds.isEmpty() &&
                    error.getMessage().equals("error")
            );
        }
    }

    @Test
    void resolvePromiseAllSameTypeError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        List<Long> timerIds = new ArrayList<>();
        try {
            timerIds =
                Promise.allSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future())).block();
            Assertions.fail();
        } catch (Exception error) {
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start >= 5000 &&
                    timerIds.isEmpty() &&
                    error.getMessage().equals("error")
            );
        }
    }

    @Test
    void resolvePromiseAllSettle(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        List<Object> timerIds = Promise
            .allSettled(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
        Assertions.assertTrue(end - start >= 5000 && timerIds.get(0) != timerIds.get(1));
    }

    @Test
    void resolvePromiseAllSameTypeSettle(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        List<Long> timerIds = Promise
            .allSettledSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
        Assertions.assertTrue(end - start >= 5000 && !Objects.equals(timerIds.get(0), timerIds.get(1)));
    }

    @Test
    void resolvePromiseAllSettleError() {
        Vertx vertx = Vertx.vertx();
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        List<Object> timerIds = Promise
            .allSettled(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        Assertions.assertTrue(
            end - start >= 5000 &&
                timerIds.size() == 2 &&
                (long) timerIds.get(0) == 0 &&
                ((RuntimeException) timerIds.get(1)).getMessage().equals("error")
        );
    }

    @Test
    void resolvePromiseRace() {
        Vertx vertx = Vertx.vertx();
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Long timerId = (Long) Promise
            .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println("!!!!" + start + ":" + end + ":" + timerId);
        Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId == 0);
    }

    @Test
    void resolvePromiseRaceSameType() {
        Vertx vertx = Vertx.vertx();
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Long timerId = Promise
            .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .block();
        Long end = System.currentTimeMillis();
        System.out.println("!!!!" + start + ":" + end + ":" + timerId);
        Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId == 0);
    }

    @Test
    void resolvePromiseRaceNoError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseRaceSameTypeNoError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Long timerId = Promise
                .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId != null);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseRaceToError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Assertions.fail();
        } catch (Exception error) {
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start > 2900 && end - start < 3500 && error.getMessage().equals("error")
            );
        }
    }

    @Test
    void resolvePromiseRaceToRecoverError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()).doCatch(throwable -> 110L))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start > 2900 && end - start < 3500 && (long) timerId == 110L
            );

        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseRaceSameTypeToError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Long timerId = Promise
                .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Assertions.fail();
        } catch (Exception error) {
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start > 2900 && end - start < 3500
            );
        }
    }

    @Test
    void resolvePromiseAnyNoError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseAnySameTypeNoError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Long timerId = Promise
                .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 2900 && end - start < 3500);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseAny2NoError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 4900 && end - start < 5100 && timerId instanceof Long);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseAny2NoErrorRecover(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()).doCatch(throwable -> 110L))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId instanceof Long && (Long) timerId == 110L);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseAny2SameTypeNoError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Long timerId = Promise
                .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(end - start > 4900 && end - start < 5100);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void resolvePromiseAnyError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, timerId -> sleep1.fail("error1"));
        vertx.setTimer(3000, timerId -> sleep2.fail("error2"));

        Long start = System.currentTimeMillis();

        try {
            Object timerId = Promise
                .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Assertions.fail();
        } catch (Exception error) {
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start > 4900 && end - start < 5100 && error.getMessage().equals("error1")
            );
        }
    }

    @Test
    void resolvePromiseAnySameTypeError(Vertx vertx) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, timerId -> sleep1.fail("error"));
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        try {
            Long timerId = Promise
                .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .block();
            Assertions.fail();
        } catch (Exception error) {
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start > 4900 && end - start < 5100
            );
        }
    }

    @Test
    void deferResolve() {
        try {
            Long start = System.currentTimeMillis();
            var p = Promise.deferResolve().then(System::currentTimeMillis);
            Thread.sleep(1000);
            Long end = p.block();
            System.out.println(start + ":" + end + ":" + (end - start));
            Assertions.assertTrue(end - start > 900);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void deferResolve2() {
        try {
            Long start = System.currentTimeMillis();

            Thread.sleep(1000);

            var p = Promise.deferResolve().thenPromise(() -> {
                var timeFuture = Future.<Long>future(promise -> promise.complete(System.currentTimeMillis()));
                return Promise.resolve(timeFuture);
            });

            Long end = p.block();
            System.out.println(start + ":" + end + ":" + (end - start));
            Assertions.assertTrue(end - start > 900);
        } catch (Exception error) {
            Assertions.fail();
        }
    }

    @Test
    void reject() {
        try {
            Promise.reject().block();
        } catch (Exception error) {
            if (error instanceof RuntimeException) {
                Assertions.assertEquals(error.getMessage(), "reject");
            } else {
                Assertions.fail();
            }
        }
    }

    @Test
    void rejectCustomError() {
        try {
            Promise.reject(new NullPointerException()).block();
        } catch (Exception error) {
            if (error instanceof NullPointerException) {
                Assertions.assertTrue(true);
            } else {
                Assertions.fail();
            }
        }
    }

    @Test
    @SneakyThrows
    void then(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(() -> {
                io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                var t2 = vertx.setTimer(5000, sleep2::complete);
                return sleep2.future();
            })
            .then(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    System.out.println(start + ":" + end + ":" + (end - start));
                    try {
                        Assertions.assertTrue(end - start > 8000 && end - start < 8500 && timerId == 1L);
                        testContext.completeNow();
                    } catch (Throwable error) {
                        testContext.failNow(error);
                    }
                }
            )
            .block();
    }

    @Test
    @SneakyThrows
    void thenConsumer(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    System.out.println(start + ":" + end + ":" + (end - start));
                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        testContext.completeNow();
                    } catch (Throwable error) {
                        testContext.failNow(error);
                    }
                }
            )
            .then(testContext::completeNow)
            .block();
    }

    @Test
    @SneakyThrows
    void thenRunnable(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                () -> {
                    Long end = System.currentTimeMillis();

                    System.out.println(start + ":" + end + ":" + (end - start));
                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);

                    } catch (Throwable error) {
                        testContext.failNow(error);
                    }
                }
            )
            .then(testContext::completeNow)
            .block();
    }

    @Test
    @SneakyThrows
    void thenFunction(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        return 2;
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return -1;
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenSupplier(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                () -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                        return 2;
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return -1;
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenPromiseFunction(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenPromise(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        return Promise.resolve(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Promise.resolve(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenPromiseSupplier(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenPromise(
                () -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                        return Promise.resolve(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Promise.resolve(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenPromise(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenPromise(Promise.resolve(2))
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenFutureFunction(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        return Future.succeededFuture(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Future.succeededFuture(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenFutureSupplier(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(
                () -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                        return Future.succeededFuture(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Future.succeededFuture(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenFuture(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(Future.succeededFuture(2))
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .block();
    }

    @Test
    @SneakyThrows
    void thenTryCatch(Vertx vertx, VertxTestContext testContext) {
        Checkpoint checkpoint = testContext.checkpoint(2);

        io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
        vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

        var result = Promise
            .resolve(sleep3s.future())
            .then(sleep3sTimerId -> {
                if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                return sleep3sTimerId;
            })
            .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
            .then(
                sleep5sTimerId -> {
                    System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                }
            )
            .doCatch(error -> {
                checkpoint.flag();
                System.out.println("抓到了一个错误:" + error.getMessage());
            })
            .block();
        if (result == null) {
            checkpoint.flag();
        } else {
            testContext.failNow("返回值有误");
        }
    }

    @Test
    @SneakyThrows
    void thenTryCatchReturnValue(Vertx vertx, VertxTestContext testContext) {
        Checkpoint checkpoint = testContext.checkpoint(2);

        io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
        vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

        var result = Promise
            .resolve(sleep3s.future())
            .then(sleep3sTimerId -> {
                if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                return sleep3sTimerId;
            })
            .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
            .then(
                sleep5sTimerId -> {
                    System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                    return 0;
                }
            )
            .doCatch(error -> {
                checkpoint.flag();
                System.out.println("抓到了一个错误:" + error.getMessage());
                return 1;
            })
            .block();
        if (result == 1) {
            checkpoint.flag();
        } else {
            testContext.failNow("返回值有误");
        }
    }

    @Test
    @SneakyThrows
    void thenTryCatchFinally(Vertx vertx, VertxTestContext testContext) {
        Checkpoint checkpoint = testContext.checkpoint(3);

        io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
        vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

        var result = Promise
            .resolve(sleep3s.future())
            .then(sleep3sTimerId -> {
                if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                return sleep3sTimerId;
            })
            .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
            .then(
                sleep5sTimerId -> {
                    System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                }
            )
            .doCatch(error -> {
                checkpoint.flag();
                System.out.println("抓到了一个错误:" + error.getMessage());
            })
            .doFinally(
                () -> {
                    System.out.println("finally");
                    checkpoint.flag();
                }
            )
            .block();
        if (result == null) {
            checkpoint.flag();

            if (!testContext.unsatisfiedCheckpointCallSites().isEmpty()) {
                testContext.failNow("没有成功catch");
            } else {
                testContext.completeNow();
            }

        } else {
            testContext.failNow("返回值有误");
        }
    }

    @Test
    void blockTimeout() {
        try {
            Promise.<Long>resolve(doneCallback -> Vertx.vertx().setTimer(3000, doneCallback))
                .block(200, TimeUnit.MICROSECONDS);
            Assertions.fail();
        } catch (Throwable error) {
            Assertions.assertTrue(true);
        }
    }
}

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package team.qtk.promise;

import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.junit5.Checkpoint;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.extension.ExtendWith;

import java.math.BigDecimal;
import java.util.Objects;

@ExtendWith(VertxExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PromiseAsyncTest {

    @Test
    void resolveInteger(VertxTestContext testContext) {
        Promise.resolve(1)
            .then(value -> {
                Assertions.assertEquals(value, 1);
                testContext.completeNow();
            })
            .async();
    }

    @Test
    void resolveString(VertxTestContext testContext) {
        Promise.resolve("1")
            .then(value -> {
                Assertions.assertEquals(value, "1");
                testContext.completeNow();
            })
            .async();
    }

    @Test
    void resolveBoolean(VertxTestContext testContext) {
        Promise.resolve(true)
            .then(value -> {
                Assertions.assertEquals(value, true);
                testContext.completeNow();
            })
            .async();
    }

    @Test
    void resolveBigDecimal(VertxTestContext testContext) {
        Promise.resolve(new BigDecimal("1"))
            .then(value -> {
                Assertions.assertEquals(value, new BigDecimal("1"));
                testContext.completeNow();
            })
            .async();
    }

    @Test
    void resolve(VertxTestContext testContext) {
        Promise.resolve()
            .then(value -> {
                Assertions.assertNull(value);
                testContext.completeNow();
            })
            .async();
    }

    @Test
    void resolveFutureSuccess(VertxTestContext testContext) {
        Promise.resolve(Future.succeededFuture(null))
            .then(value -> {
                Assertions.assertNull(value);
                testContext.completeNow();
            })
            .async();
    }

    @Test
    void resolveFutureError(VertxTestContext testContext) {
        Promise.resolve(Future.failedFuture(new RuntimeException("reject")))
            .doCatch(error -> {
                if (error instanceof RuntimeException) {
                    Assertions.assertEquals(error.getMessage(), "reject");
                    testContext.completeNow();
                } else {
                    testContext.failNow("错误结果");
                }
            })
            .async();
    }

    @Test
    void resolveConsumerHandler(VertxTestContext testContext) {
        Long start = System.currentTimeMillis();
        Long[] timerIds = { 999L };
        Promise.<Long>resolve(
                doneCallback -> timerIds[0] = Vertx.vertx().setTimer(3000, doneCallback)
            )
            .then(timerId -> {
                try {
                    Long end = System.currentTimeMillis();
                    System.out.println(start + ":" + end + ":" + timerId);
                    Assertions.assertTrue(end - start > 3000 && timerIds[0].equals(timerId));
                    testContext.completeNow();
                } catch (Throwable error) {
                    testContext.failNow(error);
                }

            })
            .async();

    }

    @Test
    void resolveCompositeFutureAll(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise.<Long>resolve(CompositeFuture.all(sleep1.future(), sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
                try {
                    Assertions.assertTrue(end - start > 5000 && !timerIds.get(0).equals(timerIds.get(1)));
                    testContext.completeNow();
                } catch (Exception error) {
                    testContext.failNow(error);
                }
            })
            .async();

    }

    @Test
    void resolveCompositeFutureAny(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise.<Long>resolve(CompositeFuture.any(sleep1.future(), sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
                try {
                    Assertions.assertTrue(
                        end - start > 2900 && end - start < 3500 && timerIds.get(0) != null && timerIds.get(1) == null
                    );
                    testContext.completeNow();
                } catch (Exception error) {
                    testContext.failNow(error);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseAll(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise.all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
                try {
                    Assertions.assertTrue(end - start > 5000 && timerIds.get(0) != timerIds.get(1));
                    testContext.completeNow();
                } catch (Exception error) {
                    testContext.failNow(error);
                }
            })
            .async();

    }

    @SneakyThrows
    @Test
    void resolvePromiseAllSameType(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise
            .allSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
                try {
                    Assertions.assertTrue(end - start > 5000 && !Objects.equals(timerIds.get(0), timerIds.get(1)));
                    testContext.completeNow();
                } catch (Exception error) {
                    testContext.failNow(error);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseAllError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise.all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(() -> {
                Assertions.fail();
            })
            .doCatch(error -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":");
                try {
                    Assertions.assertTrue(
                        end - start > 5000 &&
                            error.getMessage().equals("error")
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();
    }

    @Test
    void resolvePromiseAllSameTypeError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise.all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(() -> {
                Assertions.fail();
            })
            .doCatch(error -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":");
                try {
                    Assertions.assertTrue(
                        end - start > 5000 &&
                            error.getMessage().equals("error")
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();
    }

    @Test
    void resolvePromiseAllSettle(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise
            .allSettled(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
                try {
                    Assertions.assertTrue(end - start > 5000 && timerIds.get(0) != timerIds.get(1));
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseAllSameTypeSettle(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise
            .allSettledSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
                try {
                    Assertions.assertTrue(end - start > 5000 && !Objects.equals(timerIds.get(0), timerIds.get(1)));
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseAllSettleError(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .allSettled(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerIds -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(
                        end - start > 5000 &&
                            timerIds.size() == 2 &&
                            (long) timerIds.get(0) == 0 &&
                            ((RuntimeException) timerIds.get(1)).getMessage().equals("error")
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseRace(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise
            .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                System.out.println("!!!!" + start + ":" + end + ":" + timerId);
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3500 && (Long) timerId == 0);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseRaceSameType(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, sleep2::complete);

        Long start = System.currentTimeMillis();

        Promise
            .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                System.out.println("!!!!" + start + ":" + end + ":" + timerId);
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId == 0);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseRaceNoError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();
        Promise
            .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .doCatch(throwable -> {
                Assertions.fail();
            })
            .async();

    }

    @Test
    void resolvePromiseRaceSameTypeNoError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();
        Promise
            .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId != null);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .doCatch(throwable -> {
                Assertions.fail();
            })
            .async();
    }

    @Test
    void resolvePromiseRaceToError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();
        Promise
            .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .doCatch(error -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(
                        end - start > 2900 && end - start < 3500 && error.getMessage().equals("error")
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();
    }

    @Test
    void resolvePromiseRaceToRecoverError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()).doCatch(throwable -> 110L))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(
                        end - start > 2900 && end - start < 3500 && (long) timerId == 110L
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();
    }

    @Test
    void resolvePromiseRaceSameTypeToError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();
        Promise
            .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(() -> {
                Assertions.fail();
            })
            .doCatch(error -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(
                        end - start > 2900 && end - start < 3500
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseAnyNoError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    void resolvePromiseAnySameTypeNoError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep1::complete);
        vertx.setTimer(5000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();
        Promise
            .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(() -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3500);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .doCatch(error -> {
                Assertions.fail();
            })
            .async();
    }

    @Test
    void resolvePromiseAny2NoError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 4900 && end - start < 5100 && timerId instanceof Long);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .doCatch(error -> {
                Assertions.fail();
            })
            .async();
    }

    @Test
    void resolvePromiseAny2NoErrorRecover(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()).doCatch(throwable -> 110L))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId instanceof Long && (Long) timerId == 110L);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .doCatch(error -> {
                Assertions.fail();
            })
            .async();

    }

    @Test
    void resolvePromiseAny2SameTypeNoError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, sleep1::complete);
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(timerId -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(end - start > 4900 && end - start < 5100);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .doCatch(error -> {
                Assertions.fail();
            })
            .async();
    }

    @Test
    void resolvePromiseAnyError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, timerId -> sleep1.fail("error1"));
        vertx.setTimer(3000, timerId -> sleep2.fail("error2"));

        Long start = System.currentTimeMillis();
        Promise
            .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(() -> {
                Assertions.fail();
            })
            .doCatch(error -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(
                        end - start > 4900 && end - start < 5100 && error.getMessage().equals("error1")
                    );
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();
    }

    @Test
    void resolvePromiseAnySameTypeError(Vertx vertx, VertxTestContext testContext) {
        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
        vertx.setTimer(5000, timerId -> sleep1.fail("error"));
        vertx.setTimer(3000, timerId -> sleep2.fail("error"));

        Long start = System.currentTimeMillis();

        Promise
            .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
            .then(() -> {
                Assertions.fail();
            })
            .doCatch(error -> {
                Long end = System.currentTimeMillis();
                try {
                    Assertions.assertTrue(
                        end - start > 4900 && end - start < 5100
                    );

                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            })
            .async();

    }

    @Test
    @SneakyThrows
    void deferResolve(VertxTestContext testContext) {

        Long start = System.currentTimeMillis();
        var p = Promise.deferResolve().then(System::currentTimeMillis);
        Thread.sleep(1000);
        p.then(end -> {
            System.out.println(start + ":" + end + ":" + (end - start));
            try {
                Assertions.assertTrue(end - start > 900);

                testContext.completeNow();
            } catch (Exception err) {
                testContext.failNow(err);
            }
        }).async();
    }

    @Test
    @SneakyThrows
    void deferResolve2(VertxTestContext testContext) {
        Long start = System.currentTimeMillis();

        Thread.sleep(1000);

        var p = Promise.deferResolve().thenPromise(() -> {
            var timeFuture = Future.<Long>future(promise -> promise.complete(System.currentTimeMillis()));
            return Promise.resolve(timeFuture);
        });
        p.then(
            end -> {
                System.out.println(start + ":" + end + ":" + (end - start));
                try {
                    Assertions.assertTrue(end - start > 900);
                    testContext.completeNow();
                } catch (Exception err) {
                    testContext.failNow(err);
                }
            }
        ).async();
    }

    @Test
    void reject(VertxTestContext testContext) {

        Promise.reject()
            .doCatch(error -> {
                if (error instanceof RuntimeException) {
                    Assertions.assertEquals(error.getMessage(), "reject");
                    testContext.completeNow();
                } else {
                    Assertions.fail();
                }
            }).async();
    }

    @Test
    void rejectCustomError(VertxTestContext testContext) {
        Promise.reject(new NullPointerException())
            .doCatch(error -> {
                if (error instanceof NullPointerException) {
                    Assertions.assertTrue(true);
                    testContext.completeNow();
                } else {
                    Assertions.fail();
                }
            }).async();
    }

    @Test
    @SneakyThrows
    void then(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(() -> {
                io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                var t2 = vertx.setTimer(5000, sleep2::complete);
                return sleep2.future();
            })
            .then(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    System.out.println(start + ":" + end + ":" + (end - start));
                    try {
                        Assertions.assertTrue(end - start > 8000 && end - start < 8500 && timerId == 1L);
                        testContext.completeNow();
                    } catch (Throwable error) {
                        testContext.failNow(error);
                    }
                }
            )
            .async();
    }

    @Test
    @SneakyThrows
    void thenConsumer(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    System.out.println(start + ":" + end + ":" + (end - start));
                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        testContext.completeNow();
                    } catch (Throwable error) {
                        testContext.failNow(error);
                    }
                }
            )
            .then(testContext::completeNow)
            .async();
    }

    @Test
    @SneakyThrows
    void thenRunnable(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                () -> {
                    Long end = System.currentTimeMillis();

                    System.out.println(start + ":" + end + ":" + (end - start));
                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);

                    } catch (Throwable error) {
                        testContext.failNow(error);
                    }
                }
            )
            .then(testContext::completeNow)
            .async();
    }

    @Test
    @SneakyThrows
    void thenFunction(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        return 2;
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return -1;
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenSupplier(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .then(
                () -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                        return 2;
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return -1;
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenPromiseFunction(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenPromise(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        return Promise.resolve(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Promise.resolve(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenPromiseSupplier(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenPromise(
                () -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                        return Promise.resolve(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Promise.resolve(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenPromise(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenPromise(Promise.resolve(2))
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenFutureFunction(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(
                timerId -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                        return Future.succeededFuture(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Future.succeededFuture(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenFutureSupplier(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(
                () -> {
                    Long end = System.currentTimeMillis();

                    try {
                        Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                        return Future.succeededFuture(2);
                    } catch (Throwable error) {
                        testContext.failNow(error);
                        return Future.succeededFuture(-1);
                    }

                }
            )
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenFuture(VertxTestContext testContext) {
        Vertx vertx = Vertx.vertx();

        io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
        var t1 = vertx.setTimer(3000, sleep1::complete);

        Long start = System.currentTimeMillis();

        Promise.resolve(sleep1.future())
            .thenFuture(Future.succeededFuture(2))
            .then(lastResult -> {
                if (lastResult == 2) {
                    testContext.completeNow();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();
    }

    @Test
    @SneakyThrows
    void thenTryCatch(Vertx vertx, VertxTestContext testContext) {
        Checkpoint checkpoint = testContext.checkpoint(2);

        io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
        vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

        Promise
            .resolve(sleep3s.future())
            .then(sleep3sTimerId -> {
                if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                return sleep3sTimerId;
            })
            .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
            .then(
                sleep5sTimerId -> {
                    System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                }
            )
            .doCatch(error -> {
                checkpoint.flag();
                System.out.println("抓到了一个错误:" + error.getMessage());
            })
            .then(result -> {
                if (result == null) {
                    checkpoint.flag();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();

    }

    @Test
    @SneakyThrows
    void thenTryCatchReturnValue(Vertx vertx, VertxTestContext testContext) {
        Checkpoint checkpoint = testContext.checkpoint(2);

        io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
        vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

        Promise
            .resolve(sleep3s.future())
            .then(sleep3sTimerId -> {
                if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                return sleep3sTimerId;
            })
            .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
            .then(
                sleep5sTimerId -> {
                    System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                    return 0;
                }
            )
            .doCatch(error -> {
                checkpoint.flag();
                System.out.println("抓到了一个错误:" + error.getMessage());
                return 1;
            })
            .then(result -> {
                if (result == 1) {
                    checkpoint.flag();
                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();

    }

    @Test
    @SneakyThrows
    void thenTryCatchFinally(Vertx vertx, VertxTestContext testContext) {
        Checkpoint checkpoint = testContext.checkpoint(3);

        io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
        io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
        vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
        vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

        Promise
            .resolve(sleep3s.future())
            .then(sleep3sTimerId -> {
                if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                return sleep3sTimerId;
            })
            .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
            .then(
                sleep5sTimerId -> {
                    System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                }
            )
            .doCatch(error -> {
                checkpoint.flag();
                System.out.println("抓到了一个错误:" + error.getMessage());
            })
            .doFinally(
                () -> {
                    System.out.println("finally");
                    checkpoint.flag();
                }
            )
            .then(result -> {
                if (result == null) {
                    checkpoint.flag();

                    if (!testContext.unsatisfiedCheckpointCallSites().isEmpty()) {
                        testContext.failNow("没有成功catch");
                    } else {
                        testContext.completeNow();
                    }

                } else {
                    testContext.failNow("返回值有误");
                }
            })
            .async();

    }

}

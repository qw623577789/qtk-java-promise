/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package team.qtk.promise;

import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.impl.VertxImpl;
import io.vertx.junit5.Checkpoint;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.extension.ExtendWith;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@ExtendWith(VertxExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PromiseAwaitTest {

    @Test
    void resolveInteger(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Assertions.assertEquals(Promise.resolve(1).await(), 1);
            testContext.completeNow();
        });
    }

    @Test
    void resolveString(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Assertions.assertEquals(Promise.resolve("1").await(), "1");
            testContext.completeNow();
        });
    }

    @Test
    void resolveBoolean(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Assertions.assertEquals(Promise.resolve(true).await(), true);
            testContext.completeNow();
        });
    }

    @Test
    void resolveBigDecimal(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Assertions.assertEquals(Promise.resolve(new BigDecimal("1")).await(), new BigDecimal("1"));
            testContext.completeNow();
        });
    }

    @Test
    void resolve(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Assertions.assertNull(Promise.resolve().await());
            testContext.completeNow();
        });

    }

    @Test
    void resolveFutureSuccess(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Assertions.assertNull(Promise.resolve(Future.succeededFuture(null)).await());
            testContext.completeNow();
        });

    }

    @Test
    void resolveFutureError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            try {
                Assertions.assertNull(Promise.resolve(Future.failedFuture(new RuntimeException("reject"))).await());
            } catch (Exception error) {
                if (error instanceof RuntimeException) {
                    Assertions.assertEquals(error.getMessage(), "reject");
                    testContext.completeNow();
                } else {
                    Assertions.fail();

                    testContext.failNow("结果非预期");
                }
            }

        });

    }

    @Test
    void resolveConsumerHandler(Vertx vertx, VertxTestContext testContext) {

        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Promise.<Long>resolve(doneCallback -> Vertx.vertx().setTimer(3000, doneCallback)).await();

            Long start = System.currentTimeMillis();
            Long[] timerIds = { 999L };
            Long timerId = Promise.<Long>resolve(
                    doneCallback -> timerIds[0] = Vertx.vertx().setTimer(3000, doneCallback)
                )
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerId);
            Assertions.assertTrue(end - start > 3000 && timerIds[0].equals(timerId));
            testContext.completeNow();
        });
    }

    @Test
    void resolveCompositeFutureAll(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            List<Long> timerIds = Promise
                .<Long>resolve(CompositeFuture.all(sleep1.future(), sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            try {
                Assertions.assertTrue(end - start > 5000 && !timerIds.get(0).equals(timerIds.get(1)));
                testContext.completeNow();
            } catch (Exception error) {
                testContext.failNow(error);
            }
        });
    }

    @Test
    void resolveCompositeFutureAny(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            List<Long> timerIds = Promise
                .<Long>resolve(CompositeFuture.any(sleep1.future(), sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(
                end - start > 2900 && end - start < 3500 && timerIds.get(0) != null && timerIds.get(1) == null
            );

            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseAll(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            List<Object> timerIds = Promise
                .all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(end - start >= 5000 && timerIds.get(0) != timerIds.get(1));
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseAllDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            var p1 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
                vertx.setTimer(3000, sleep1::complete);
                return Promise.resolve(sleep1.future());
            });

            var p2 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                vertx.setTimer(5000, sleep2::complete);
                return Promise.resolve(sleep2.future());
            });

            Long start = System.currentTimeMillis();

            List<Object> timerIds = Promise
                .all(p1, p2)
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(end - start >= 5000 && timerIds.get(0) != timerIds.get(1));
            testContext.completeNow();
        });
    }

    @SneakyThrows
    @Test
    void resolvePromiseAllSameType(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            List<Long> timerIds = Promise
                .allSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(end - start > 5000 && !Objects.equals(timerIds.get(0), timerIds.get(1)));
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseAllError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            List<Object> timerIds = new ArrayList<>();
            try {
                timerIds = Promise.all(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future())).await();
                Assertions.fail();
            } catch (Exception error) {
                Long end = System.currentTimeMillis();
                System.out.println(start + ":" + end + ":");
                Assertions.assertTrue(
                    end - start > 5000 &&
                        timerIds.isEmpty() &&
                        error.getMessage().equals("error")
                );
                testContext.completeNow();
            }
        });
    }

    @Test
    void resolvePromiseAllSameTypeError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            List<Long> timerIds = new ArrayList<>();
            try {
                timerIds =
                    Promise.allSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future())).await();
                Assertions.fail();
            } catch (Exception error) {
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(
                    end - start > 5000 &&
                        timerIds.isEmpty() &&
                        error.getMessage().equals("error")
                );
                testContext.completeNow();
            }
        });
    }

    @Test
    void resolvePromiseAllSettle(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            List<Object> timerIds = Promise
                .allSettled(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(end - start > 5000 && timerIds.get(0) != timerIds.get(1));
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseAllSettleDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            var p1 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
                vertx.setTimer(3000, sleep1::complete);
                return Promise.resolve(sleep1.future());
            });

            var p2 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                vertx.setTimer(5000, sleep2::complete);
                return Promise.resolve(sleep2.future());
            });

            Long start = System.currentTimeMillis();

            List<Object> timerIds = Promise
                .allSettled(p1, p2)
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(end - start > 5000 && timerIds.get(0) != timerIds.get(1));
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseAllSameTypeSettle(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            List<Long> timerIds = Promise
                .allSettledSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println(start + ":" + end + ":" + timerIds.get(0) + ":" + timerIds.get(1));
            Assertions.assertTrue(end - start > 5000 && !Objects.equals(timerIds.get(0), timerIds.get(1)));
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseAllSettleError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            List<Object> timerIds = Promise
                .allSettled(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            Assertions.assertTrue(
                end - start > 5000 &&
                    timerIds.size() == 2 &&
                    (long) timerIds.get(0) == 0 &&
                    ((RuntimeException) timerIds.get(1)).getMessage().equals("error")
            );
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseRace(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            Long timerId = (Long) Promise
                .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println("!!!!" + start + ":" + end + ":" + timerId);
            Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId == 0);
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseRaceDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            var p1 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
                vertx.setTimer(3000, sleep1::complete);
                return Promise.resolve(sleep1.future());
            });

            var p2 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                vertx.setTimer(5000, sleep2::complete);
                return Promise.resolve(sleep2.future());
            });

            Long start = System.currentTimeMillis();

            Long timerId = (Long) Promise
                .race(p1, p2)
                .await();
            Long end = System.currentTimeMillis();
            System.out.println("!!!!" + start + ":" + end + ":" + timerId);
            Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId == 0);
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseRaceSameType(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, sleep2::complete);

            Long start = System.currentTimeMillis();

            Long timerId = Promise
                .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                .await();
            Long end = System.currentTimeMillis();
            System.out.println("!!!!" + start + ":" + end + ":" + timerId);
            Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId == 0);
            testContext.completeNow();
        });
    }

    @Test
    void resolvePromiseRaceNoError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }

        });
    }

    @Test
    void resolvePromiseRaceSameTypeNoError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Long timerId = Promise
                    .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId != null);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseRaceToError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, sleep1::complete);
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Assertions.fail();
            } catch (Exception error) {
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(
                    end - start > 2900 && end - start < 3500 && error.getMessage().equals("error")
                );
                testContext.completeNow();
            }
        });
    }

    @Test
    void resolvePromiseRaceToRecoverError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, sleep1::complete);
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .race(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()).doCatch(throwable -> 110L))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(
                    end - start > 2900 && end - start < 3500 && (long) timerId == 110L
                );
                testContext.completeNow();

            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseRaceSameTypeToError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, sleep1::complete);
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Long timerId = Promise
                    .raceSameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Assertions.fail();
            } catch (Exception error) {
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(
                    end - start > 2900 && end - start < 3500
                );
                testContext.completeNow();
            }
        });
    }

    @Test
    void resolvePromiseAnyNoError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseAnyDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            var p1 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
                vertx.setTimer(3000, sleep1::complete);
                return Promise.resolve(sleep1.future());
            });

            var p2 = Promise.deferResolve().thenPromise(() -> {
                io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                vertx.setTimer(5000, sleep2::complete);
                return Promise.resolve(sleep2.future());
            });

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .any(p1, p2)
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 2900 && end - start < 3500 && timerId instanceof Long);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseAnySameTypeNoError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep1::complete);
            vertx.setTimer(5000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Long timerId = Promise
                    .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 2900 && end - start < 3500);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseAny2NoError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, sleep1::complete);
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 4900 && end - start < 5100 && timerId instanceof Long);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseAny2NoErrorRecover(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, sleep1::complete);
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()).doCatch(throwable -> 110L))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId instanceof Long && (Long) timerId == 110L);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseAny2SameTypeNoError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, sleep1::complete);
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Long timerId = Promise
                    .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(end - start > 4900 && end - start < 5100);
                testContext.completeNow();
            } catch (Exception error) {
                Assertions.fail();
            }
        });
    }

    @Test
    void resolvePromiseAnyError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, timerId -> sleep1.fail("error1"));
            vertx.setTimer(3000, timerId -> sleep2.fail("error2"));

            Long start = System.currentTimeMillis();

            try {
                Object timerId = Promise
                    .any(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Assertions.fail();
            } catch (Exception error) {
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(
                    end - start > 4900 && end - start < 5100 && error.getMessage().equals("error1")
                );
                testContext.completeNow();
            }
        });
    }

    @Test
    void resolvePromiseAnySameTypeError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
            vertx.setTimer(5000, timerId -> sleep1.fail("error"));
            vertx.setTimer(3000, timerId -> sleep2.fail("error"));

            Long start = System.currentTimeMillis();

            try {
                Long timerId = Promise
                    .anySameType(Promise.resolve(sleep1.future()), Promise.resolve(sleep2.future()))
                    .await();
                Assertions.fail();
                testContext.failNow("意外结果");
            } catch (Exception error) {
                Long end = System.currentTimeMillis();
                Assertions.assertTrue(
                    end - start > 4900 && end - start < 5100
                );
                testContext.completeNow();
            }
        });
    }

    @Test
    void deferResolve(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            try {
                Long start = System.currentTimeMillis();
                var p = Promise.deferResolve().then(System::currentTimeMillis);
                Thread.sleep(1000);
                Long end = p.await();
                System.out.println(start + ":" + end + ":" + (end - start));
                Assertions.assertTrue(end - start > 900);
                testContext.completeNow();
            } catch (Exception error) {
                testContext.failNow("意外结果");

            }
        });
    }

    @Test
    void deferResolve2(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            try {
                Long start = System.currentTimeMillis();

                Thread.sleep(1000);

                var p = Promise.deferResolve().thenPromise(() -> {
                    var timeFuture = Future.<Long>future(promise -> promise.complete(System.currentTimeMillis()));
                    return Promise.resolve(timeFuture);
                });

                Long end = p.await();
                System.out.println(start + ":" + end + ":" + (end - start));
                Assertions.assertTrue(end - start > 900);
                testContext.completeNow();
            } catch (Exception error) {
                testContext.failNow("意外结果");
            }
        });
    }

    @Test
    void reject(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            try {
                Promise.reject().await();
            } catch (Exception error) {
                if (error instanceof RuntimeException) {
                    Assertions.assertEquals(error.getMessage(), "reject");
                    testContext.completeNow();
                } else {
                    testContext.failNow("意外结果");
                }
            }
        });
    }

    @Test
    void rejectCustomError(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            try {
                Promise.reject(new NullPointerException()).await();
            } catch (Exception error) {
                if (error instanceof NullPointerException) {
                    Assertions.assertTrue(true);
                    testContext.completeNow();
                } else {
                    testContext.failNow("意外结果");
                }
            }
        });
    }

    @Test
    @SneakyThrows
    void then(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenFuture(() -> {
                    io.vertx.core.Promise<Long> sleep2 = io.vertx.core.Promise.promise();
                    var t2 = vertx.setTimer(5000, sleep2::complete);
                    return sleep2.future();
                })
                .then(
                    timerId -> {
                        Long end = System.currentTimeMillis();

                        System.out.println(start + ":" + end + ":" + (end - start));
                        try {
                            Assertions.assertTrue(end - start > 8000 && end - start < 8500 && timerId == 1L);
                            testContext.completeNow();
                        } catch (Throwable error) {
                            testContext.failNow(error);
                        }
                    }
                )
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenConsumer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .then(
                    timerId -> {
                        Long end = System.currentTimeMillis();

                        System.out.println(start + ":" + end + ":" + (end - start));
                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                            testContext.completeNow();
                        } catch (Throwable error) {
                            testContext.failNow(error);
                        }
                    }
                )
                .then(testContext::completeNow)
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenRunnable(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .then(
                    () -> {
                        Long end = System.currentTimeMillis();

                        System.out.println(start + ":" + end + ":" + (end - start));
                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100);

                        } catch (Throwable error) {
                            testContext.failNow(error);
                        }
                    }
                )
                .then(testContext::completeNow)
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenFunction(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .then(
                    timerId -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                            return 2;
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return -1;
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenSupplier(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .then(
                    () -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                            return 2;
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return -1;
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenPromiseFunction(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenPromise(
                    timerId -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                            return Promise.resolve(2);
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return Promise.resolve(-1);
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenPromiseFunctionDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenPromise(
                    timerId -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                            return Promise.deferResolve().then(() -> 2);
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return Promise.resolve(-1);
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenPromiseSupplier(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenPromise(
                    () -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                            return Promise.resolve(2);
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return Promise.resolve(-1);
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenPromiseSupplierDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenPromise(
                    () -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                            return Promise.deferResolve().then(() -> 2);
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return Promise.resolve(-1);
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenPromise(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenPromise(Promise.resolve(2))
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenPromiseDefer(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenPromise(Promise.deferResolve().then(() -> 2))
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenFutureFunction(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenFuture(
                    timerId -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100 && timerId == 0);
                            return Future.succeededFuture(2);
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return Future.succeededFuture(-1);
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenFutureSupplier(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {

            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenFuture(
                    () -> {
                        Long end = System.currentTimeMillis();

                        try {
                            Assertions.assertTrue(end - start > 2900 && end - start < 3100);
                            return Future.succeededFuture(2);
                        } catch (Throwable error) {
                            testContext.failNow(error);
                            return Future.succeededFuture(-1);
                        }

                    }
                )
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenFuture(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            io.vertx.core.Promise<Long> sleep1 = io.vertx.core.Promise.promise();
            var t1 = vertx.setTimer(3000, sleep1::complete);

            Long start = System.currentTimeMillis();

            Promise.resolve(sleep1.future())
                .thenFuture(Future.succeededFuture(2))
                .then(lastResult -> {
                    if (lastResult == 2) {
                        testContext.completeNow();
                    } else {
                        testContext.failNow("返回值有误");
                    }
                })
                .await();
        });
    }

    @Test
    @SneakyThrows
    void thenTryCatch(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Checkpoint checkpoint = testContext.checkpoint(2);

            io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
            vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

            var result = Promise
                .resolve(sleep3s.future())
                .then(sleep3sTimerId -> {
                    if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                    return sleep3sTimerId;
                })
                .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
                .then(
                    sleep5sTimerId -> {
                        System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                    }
                )
                .doCatch(error -> {
                    checkpoint.flag();
                    System.out.println("抓到了一个错误:" + error.getMessage());
                })
                .await();
            if (result == null) {
                checkpoint.flag();
            } else {
                testContext.failNow("返回值有误");
            }
        });
    }

    @Test
    @SneakyThrows
    void thenTryCatchReturnValue(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Checkpoint checkpoint = testContext.checkpoint(2);

            io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
            vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

            var result = Promise
                .resolve(sleep3s.future())
                .then(sleep3sTimerId -> {
                    if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                    return sleep3sTimerId;
                })
                .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
                .then(
                    sleep5sTimerId -> {
                        System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                        return 0;
                    }
                )
                .doCatch(error -> {
                    checkpoint.flag();
                    System.out.println("抓到了一个错误:" + error.getMessage());
                    return 1;
                })
                .await();
            if (result == 1) {
                checkpoint.flag();
            } else {
                testContext.failNow("返回值有误");
            }
        });
    }

    @Test
    @SneakyThrows
    void thenTryCatchFinally(Vertx vertx, VertxTestContext testContext) {
        ((VertxImpl) vertx).createVirtualThreadContext().runOnContext(v -> {
            Checkpoint checkpoint = testContext.checkpoint(3);

            io.vertx.core.Promise<Long> sleep3s = io.vertx.core.Promise.promise();
            io.vertx.core.Promise<Long> sleep5s = io.vertx.core.Promise.promise();
            vertx.setTimer(3000, sleep3s::complete); //睡眠3s后返回timerId
            vertx.setTimer(5000, sleep5s::complete); //睡眠5s后返回timerId

            var result = Promise
                .resolve(sleep3s.future())
                .then(sleep3sTimerId -> {
                    if (1 == 1) throw new RuntimeException("在这里抛了个错。。。");
                    return sleep3sTimerId;
                })
                .thenPromise(sleep3sTimerId -> Promise.resolve(sleep5s.future()))
                .then(
                    sleep5sTimerId -> {
                        System.out.println("sleep5sTimerId is:" + sleep5sTimerId);
                    }
                )
                .doCatch(error -> {
                    checkpoint.flag();
                    System.out.println("抓到了一个错误:" + error.getMessage());
                })
                .doFinally(
                    () -> {
                        System.out.println("finally");
                        checkpoint.flag();
                    }
                )
                .await();
            if (result == null) {
                checkpoint.flag();

                if (!testContext.unsatisfiedCheckpointCallSites().isEmpty()) {
                    testContext.failNow("没有成功catch");
                } else {
                    testContext.completeNow();
                }

            } else {
                testContext.failNow("返回值有误");
            }
        });
    }

}
